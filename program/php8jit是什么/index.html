<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>PHP8JIT是什么 - 叶左</title>
    <meta property="og:title" content="PHP8JIT是什么 - 叶左">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="在谈JIT之前我们先回到比较根本的一个问题。
[&amp;hellip;] 方案1的问题在于成本问题，如果代码库已经很大的话，迁移是个非常耗费成本的工作，团队将不但放弃多年的经验积累，而且整个团队成员重新学习也是个成本很高的事情。而且PHP语言的数据结构和内置函数，可以几乎直接地描述和处理实际业务，PHP是计算机与现实业务的最直接胶合剂。这也是我一直喜欢PHP的原因。
[&amp;hellip;] 方案2是最保险 &amp;hellip;">
      <meta property="og:description" content="在谈JIT之前我们先回到比较根本的一个问题。
[&amp;hellip;] 方案1的问题在于成本问题，如果代码库已经很大的话，迁移是个非常耗费成本的工作，团队将不但放弃多年的经验积累，而且整个团队成员重新学习也是个成本很高的事情。而且PHP语言的数据结构和内置函数，可以几乎直接地描述和处理实际业务，PHP是计算机与现实业务的最直接胶合剂。这也是我一直喜欢PHP的原因。
[&amp;hellip;] 方案2是最保险 &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="https://s1.ax1x.com/2020/07/22/UbMOoQ.png">
    
    

    

    
    




    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="program">
    <header class="masthead">
      <h1><a href="/">叶左</a></h1>



      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/book/">书单</a></li>
  
  <li><a href="/posts/">日志</a></li>
  
  <li><a href="/program/">程序</a></li>
  
  <li><a href="/poem/">诗</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>PHP8JIT是什么</h1>

<h3>
  2020-07-16</h3>
<hr>


      </header>



<p>在谈JIT之前我们先回到比较根本的一个问题。</p>
<h2 id="怎么优化-php-性能">怎么优化 PHP 性能</h2>
<ul>
<li>方案1，迁移到性能更好的语言上，如Go、Java、C++。</li>
<li>方案2，通过 RPC 将功能分离出来用其它语言实现，让 PHP 做更少的事情。</li>
<li>方案3，写 PHP 扩展，在性能瓶颈地方换 C/C++。</li>
<li>方案4，优化 PHP语言本身的性能。</li>
</ul>
<h4 id="方案1">方案1</h4>
<p>方案1的问题在于成本问题，如果代码库已经很大的话，迁移是个非常耗费成本的工作，团队将不但放弃多年的经验积累，而且整个团队成员重新学习也是个成本很高的事情。而且PHP语言的数据结构和内置函数，可以几乎直接地描述和处理实际业务，PHP是计算机与现实业务的最直接胶合剂。这也是我一直喜欢PHP的原因。</p>
<h4 id="方案2">方案2</h4>
<p>方案2是最保险的方案，我们现在也是这样做的，把一些计算比较多的放在Java执行，通过RPC调用。但是PHP本身的机制以及我们实际业务的场景带来的最大问题是IO场景非常多，而PHP本身也没有多线程和异步IO的机制，所以我们现在是依赖RPC提供的并行和异步处理，但这样也不是最优的方案，还是需要等待一定的时长，而这个等待目前来看又是必须的，所以也就是JIT在实际项目中的效果不会特别明显的原因。</p>
<h4 id="方案3">方案3</h4>
<p>方案3看起来美好，实际执行起来却很难，一般来说性能瓶颈并不会很显著，大多是不断累加的结果，加上 PHP 扩展开发成本高，这种方案一般只用在公共且变化不大的基础库上，所以这种方案解决不了多少问题。</p>
<h4 id="方案4">方案4</h4>
<p>所以我们只能想方案4，也就是优化PHP的性能了。</p>
<h2 id="更快的-php">更快的 PHP</h2>
<p>同样，PHP的性能优化也有很方案：</p>
<ul>
<li>方案1，PHP语言层面的优化。</li>
<li>方案2，优化 PHP 的官方实现（也就是 Zend以及JIT）。</li>
<li>方案3，将 PHP 编译成其它语言的 bytecode（字节码），借助其它语言的虚拟机（如 JVM）来运行。</li>
<li>方案4，将 PHP 转成 C/C++，然后编译成本地代码。</li>
<li>方案5，开发更快的 PHP 虚拟机。</li>
</ul>
<h4 id="方案1-1">方案1</h4>
<p>PHP 语言层面的优化是最简单可行的，比如xhprof，也是我们之前包括现在一直在做的事情。但这个也只能优化一部分，并不能很好的解决我们的问题。</p>
<h4 id="方案2-1">方案2</h4>
<p>涉及我们的主题，放在后面说。</p>
<h4 id="方案3-1">方案3</h4>
<p>开发一个高性能的虚拟机不是件简单的事情，JVM 花了十多年才达到现在的性能，那是否能直接利用这些高性能的虚拟机来优化 PHP 的性能呢？这就是方案3的思路。</p>
<p>虽然看起来很美好，但实际上VM 总是为某个语言优化的，和器官移植一样，其它语言在上面实现会遇到很多瓶颈，比如动态的方法调用，所以这个方案很多大佬都实现并测试过，没有什么好结果。</p>
<h4 id="方案4-1">方案4</h4>
<p>它正是 HPHPc（HHVM 的前身）的做法，原理是将 PHP 代码转成 C++，然后编译为本地文件，可以认为是一种 AOT（ahead of time）的方式。</p>
<p>以下是实现的一个截图，可以通过它来大概了解：</p>
<p>[image:211020D8-932A-46B4-B2FF-C5B3A692DE4C-4107-000084AA49C945D3/hiphop-vm.png]</p>
<p>这种做法的最大优点是实现简单（相对于一个 VM 来说），而且能做很多编译优化（因为是离线的，慢点也没事），比如上面的例子就将-1优化掉了，但它很难支持 PHP 中的很多动态的方法，如 eval()、create_function()，因为这就得再内嵌一个 interpreter，成本不小，所以 HPHPc 干脆就直接不支持这些语法。</p>
<p>但由于他对于开发者并不友善，而且Facebook庞大的程序库使得开发者在进行程序更动时，必须等待数个小时的编译，所以HipHop在2013年被官方弃用 。</p>
<h4 id="方案5">方案5</h4>
<p>实现 PHP 语言不仅仅只是实现一个虚拟机那么简单，PHP 语言本身还包括了各种扩展，这些扩展和语言是一体的，Zend 不辞辛劳地实现了各种你可能会用到的功能。如果分析过 PHP 的代码，就会发现它的 C 代码除去空行注释后居然还有80+万行，而你猜其中 Zend 引擎部分有多少？只有不到10万行。</p>
<p>对于开发者来说这不是什么坏事（这也是我写PHP非常舒服的原因，大佬们已经做了很多事情，而且我还不用引入那么多其他库），但对于引擎实现者来说就很悲剧了，我们可以拿 Java 来进行对比，写个 Java 的虚拟机只需实现字节码解释及一些基础的 JNI 调用，Java 绝大部分内置库都是用 Java 实现的，所以如果不考虑性能优化，单从工作量看，实现 PHP 虚拟机比 JVM 要难得多（个人观点，Java大佬们不要喷我）。</p>
<p>接下来是 Interpreter 的实现，在解析完 PHP 后会生成 HHVM 自己设计的一种 Bytecode，存储在 ~/.hhvm.hhbc（SQLite 文件） 中以便重用，在执行 Bytecode 时和 Zend 类似，也是将不同的字节码放到不同的函数中去实现。</p>
<p>正是因为有了 Interpreter，HHVM 在对于 PHP 语法的支持上比 HPHPc 有明显改进，理论上做到完全兼容官方 PHP，但仅这么做在性能并不会比 Zend 好多少，由于无法确定变量类型，所以需要加上类似上面的条件判断语句，但这样的代码不利于现代 CPU 的执行优化。</p>
<p>对于这样的问题，就得靠 JIT 来优化了。</p>
<h2 id="hhvm实现-jit-及优化">HHVM实现 JIT 及优化</h2>
<p>那么究竟什么是 JIT？如何实现一个 JIT？</p>
<p>在动态语言中基本上都会有个 eval 方法，可以传给它一段字符串来执行，JIT 做的就是类似的事情，只不过它要拼接不是字符串，而是不同平台下的机器码，然后进行执行，但如何用 C 来实现呢？比如下面这段代码：</p>
<p>我们要实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">add4</span>(<span style="color:#66d9ef">long</span> num) {
  <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
}
</code></pre></div><p>转化为JIT就是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> code[] <span style="color:#f92672">=</span> {
  <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0xf8</span>,                   <span style="color:#75715e">// mov %rdi, %rax
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x83</span>, <span style="color:#ae81ff">0xc0</span>, <span style="color:#ae81ff">0x04</span>,             <span style="color:#75715e">// add $4, %rax
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0xc3</span>                                <span style="color:#75715e">// ret
</span><span style="color:#75715e"></span>};
memcpy(m, code, <span style="color:#66d9ef">sizeof</span>(code));
</code></pre></div><p>然而手工编写机器码很容易出错，所以最好的有一个辅助的库，比如的 Mozilla 的  <a href="https://developer.mozilla.org/en-US/docs/Nanojit">Nanojit</a>  以及 LuaJIT 的  <a href="http://luajit.org/dynasm.html">DynASM</a> （PHP8中的JIT就使用了这个库，我后面会单独讲它），但 HHVM 并没有使用这些，而是自己实现了一个只支持 x64 的，通过 mprotect 的方式来让代码可执行（在Linux中，mprotect()函数可以用来修改一段指定内存区域的保护属性）。</p>
<p>但为什么 JIT 代码会更快？你可以想想其实用 C++ 编写的代码最终编译出来也是机器码，如果只是将同样的代码手动转成了机器码，那和 GCC 生成出来的有什么区别呢？在 JIT 中更重要的优化是根据类型来生成特定的指令，从而大幅减少指令数和条件判断。</p>
<p>HHVM 首先通过 interpeter 来执行，那它会在时候使用 JIT 呢？常见的 JIT 触发条件有 2 种：</p>
<ul>
<li>trace：记录循环执行次数，如果超过一定数量就对这段代码进行 JIT。</li>
<li>method：记录函数执行次数，如果超过一定数量就对整个函数进行 JIT，甚至直接 inline。</li>
</ul>
<p>（这两种方法在PHP8JIT中都实现了）</p>
<p>JIT 的关键是猜测类型，因此某个变量的类型要是老变就很难优化，于是 HHVM 的工程师开始考虑在 PHP 语法上做手脚，加上类型的支持，推出了一个新语言 - Hack</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#75715e">&lt;?</span><span style="color:#a6e22e">hh</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point2</span> {
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">float</span> $x, $y;
  <span style="color:#66d9ef">function</span> __construct(<span style="color:#a6e22e">float</span> $x, <span style="color:#a6e22e">float</span> $y) {
    $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> $x;
    $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> $y;
  }
}
</code></pre></div><p>注意到float了吗？有了静态类型可以让 HHVM 更好地优化性能，但这也意味着和 PHP 语法不兼容，只能使用 HHVM。</p>
<p>插一个八卦，这里也就是为什么鸟哥说PHP面临分裂的风险。</p>
<h4 id="方案2-2">方案2</h4>
<p>重新来说方案2。</p>
<p>Zend 的执行过程可以分为两部分：</p>
<ul>
<li>将 PHP 编译为 opcode</li>
<li>执行 opcode</li>
</ul>
<p>所以优化 Zend 可以从这两方面来考虑。</p>
<p>PHP底层数据结构，函数，内存的优化已经完成了，也就是PHP7，比如减少程序运作时搬动的内存位数，PHP7 中储存变量的数据架构 zval 从 24 位 缩减至 16 位、Hashtable 从 72 位减少至 56 位。除了从减少内存的使用着手外，还使用了CPU 的 Cache line 的运作原理，了解程序代码如何与 CPU 互动、编译程序如何在新 CPU 架构下编译程序代码等细节。</p>
<p>优化 opcode 是一种常见的做法，可以避免重复解析 PHP，而且还能做一些静态的编译优化，比如  <a href="https://github.com/zendtech/ZendOptimizerPlus">Zend Optimizer Plus</a> ，也就是现在的Opcache，将预编译后的PHP文件存储在共享内存中以供以后的使用，避免从磁盘读取文件在进行解释的重复过程，减少时间和内存的消耗。</p>
<p>但由于 PHP 语言的动态性，这种优化方法是有局限性的。另一种考虑是优化 opcode 架构本身，如基于寄存器的方式，但这种做法修改起来工作量太大，性能提升也不会特别明显，所以投入产出比不高。</p>
<p>另一个方法是优化 opcode 的执行，首先简单提一下 Zend 是如何执行的，Zend 的 interpreter（也叫解释器）在读到 opcode 后，会根据不同的 opcode 调用不同函数（其实有些是 switch，不过为了描述方便我简化了），然后在这个函数中执行各种语言相关的操作（感兴趣的话可看看<a href="https://www.bookstack.cn/read/php-internals/0.md">《深入理解 PHP 内核》</a>这本书），所以 Zend 中并没有什么复杂封装和间接调用，作为一个解释器来说已经做得很好了。</p>
<p>想要提升 Zend 的执行性能，就需要对程序的底层执行有所解，比如函数调用其实是有开销的，所以能通过 Inline threading 优化掉，它的原理就像 C 语言中的 inline 关键字那样，但它是在运行时将相关的函数展开，然后依次执行（只是打个比方，实际实现不太一样），同时还避免了 CPU 流水线预测失败导致的浪费。</p>
<p>现在PHP8增加了JIT，在Opcache上的基础上进行的优化。</p>
<p>好了，下面开始我们的正题。</p>
<h2 id="php8-jit">PHP8 JIT</h2>
<h4 id="性能测评">性能测评</h4>
<p><a href="https://mp.weixin.qq.com/s/z6f3Ycif3539qtTQ6ZHjHQ">晚到的PHP8 JIT测评</a></p>
<p>这个是纯CPU的测试，效果比较明显，php web项目现在IO的瓶颈更大，所以实际项目效果不会这么好，具体可以等stable版本出来后再实际测试。</p>
<h4 id="php-jit流程">PHP JIT流程</h4>
<p>先看看鸟哥公众号上的一张图：</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UbMOoQ.png" alt="UbMOoQ.png"></p>
<p>他这个图实际上画错了，图上画的有了Opcache之后就不JIT了，实际上是会的。</p>
<p>后来鸟哥在blog上把图更新了，是这样：</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UbMxWn.png" alt="UbMxWn.png"></p>
<p>下面这个图也是对的：</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UbQpQ0.jpg" alt="UbQpQ0.jpg"></p>
<p>JIT实际上是对Opcache的优化，原本需要Zend VM作为中间层解释opcode，现在可以直接用JIT作为机器指令执行。所以中间少了一层执行过程，性能得到了提高。</p>
<p>一个JIT和一个调用printf的程序没有本质的区别，只是JIT产生的是机器代码，而不是像Hello, World!这样的消息。</p>
<p>PHP 的 JIT 使用了名为DynASM (Dynamic Assembler) 的库，该库将一种特定格式的一组 CPU 指令映射为许多不同 CPU 类型的汇编代码。因此，编译器只需要使用 DynASM 就可以将 opcodes 转换为特定结构体的机器码。</p>
<p>这里有一个问题：</p>
<p>如果预加载能够在执行之前将 PHP 代码解析为 Opcodes，并且 DynASM 可以将 Opcodes 编译为机器码 (Just In Time 编译) ，为什么我们不立即使用运行前编译 (Ahead of Time 编译) 立即编译 PHP 呢？</p>
<p>答案是PHP 是弱类型语言，这意味着在 Zend VM 尝试执行某个操作码之前， PHP 通常不知道变量的类型。</p>
<h2 id="jit编译">JIT编译</h2>
<p>先看一下php 8 JIT的dasc文件。</p>
<p><a href="https://github.com/zendtech/php-src/blob/jit-dynasm/ext/opcache/jit/zend_jit_x86.dasc">php-src/zend_jit_x86.dasc at jit-dynasm · zendtech/php-src · GitHub</a></p>
<p>然后源码查看了下JIT是如何实现的，包括以下两个部分:</p>
<ol>
<li>JIT编译机制
<ul>
<li>Opcache在opcode handler的替换。</li>
<li>检查每个功能执行的JIT启动条件。</li>
</ul>
</li>
<li>JIT编译处理内容
<ul>
<li>使用DynASM生成data flow graph, call graph, SSA代码。</li>
<li>运行Opcache handler替换后生成的代码。</li>
</ul>
</li>
</ol>
<h2 id="jit编译机制">JIT编译机制</h2>
<h4 id="php代码执行流程">php代码执行流程</h4>
<p>当我运行以下命令时会发生什么？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">php foo.php 
</code></pre></div><ol>
<li>sapi/cli/php_cli.c 执行main函数</li>
<li>Zend/zend.c 调用zend_execute_scripts 函数</li>
<li>用zend_compile_file函数编译</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">op_array <span style="color:#f92672">=</span> zend_compile_file(file_handle, type);
</code></pre></div><p>上述代码将文件编译为一系列字节码。</p>
<ol start="4">
<li>执行zend_execute函数</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">zend_execute(op_array, retval);
</code></pre></div><p>这个命令用来执行字节码。</p>
<h4 id="op_array">op_array</h4>
<p>在 Zend/zend_compile.h</p>
<p>_zend_op_array结构体：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> _zend_op_array {
    <span style="color:#75715e">/* Common elements */</span>
    zend_uchar type;
    zend_uchar arg_flags[<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">/* bitset of arg_info.pass_by_reference */</span>
    ...
    uint32_t last;      <span style="color:#75715e">/* number of opcodes */</span>
    zend_op <span style="color:#f92672">*</span>opcodes;
	  ...
};
</code></pre></div><p>其中的<code>zend_op *opcodes;</code>如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> _zend_op {
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>handler;
    znode_op op1;
    znode_op op2;
    znode_op result;
    uint32_t extended_value;
    uint32_t lineno;
    zend_uchar opcode;
    zend_uchar op1_type;
    zend_uchar op2_type;
    zend_uchar result_type;
};
</code></pre></div><p>_zend_op_array 和 _zend_op是一对多的关系。</p>
<h4 id="execute_ex函数">execute_ex函数</h4>
<p>in Zend/zend_vm_execute.h</p>
<p>每个zend_op的handler的执行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) { ...
	<span style="color:#66d9ef">if</span> (UNEXPECTED((ret <span style="color:#f92672">=</span> ((opcode_handler_t)OPLINE<span style="color:#f92672">-&gt;</span>handler)()) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)){
		...
		<span style="color:#66d9ef">return</span>; 
	}
	...
} ...
</code></pre></div><h4 id="使用jit编译执行">使用JIT编译执行</h4>
<p>没有JIT的话对每个op_array执行以下操作：</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UbQieU.png" alt="UbQieU.png"></p>
<p>JIT在编译时替换handler：</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UbQVY9.png" alt="UbQVY9.png"></p>
<h4 id="opcache的处理">Opcache的处理</h4>
<p>在启动时替换zend_compile_file函数</p>
<p>in ext/opcache/ZendAccelerator.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">accel_startup</span>(zend_extension <span style="color:#f92672">*</span>extension) {
	...
	<span style="color:#75715e">/* Override compiler */</span> 
	accelerator_orig_compile_file <span style="color:#f92672">=</span> zend_compile_file; 
	zend_compile_file <span style="color:#f92672">=</span> persistent_compile_file;
	...
}
</code></pre></div><p>persistent_compile_file有什么用？</p>
<ul>
<li>缓存编译的数据结构</li>
<li>Opcache独特的优化</li>
</ul>
<p>新增：替换用于JIT编译的handler（仅在启用JIT时）。</p>
<p>注意了，JIT在这里开始！</p>
<h4 id="persistent_compile_file">persistent_compile_file</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#75715e">/* zend_compile() replacement */</span>
zend_op_array <span style="color:#f92672">*</span><span style="color:#a6e22e">persistent_compile_file</span>(zend_file_handle <span style="color:#f92672">*</span>file_handle, <span style="color:#66d9ef">int</span> type) {
	...
	<span style="color:#75715e">// 如果尚未缓存
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>persistent_script) {
		<span style="color:#75715e">// 编译
</span><span style="color:#75715e"></span>		persistent_script <span style="color:#f92672">=</span> opcache_compile_file(...);
		
		<span style="color:#75715e">// 编译成功的话进行下一步
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (persistent_script) {
			persistent_script <span style="color:#f92672">=</span> cache_script_in_shared_memory(...);
		}
	}
} ...
</code></pre></div><h4 id="通往jit之路">通往JIT之路</h4>
<p>从ext/opcache/ZendAccelerator.c 的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> zend_persistent_script <span style="color:#f92672">*</span>cache_script_in_shared_memory( <span style="color:#960050;background-color:#1e0010">…</span> ) 
</code></pre></div><p>到 ext/opcache/zend_persist.c 的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">zend_persistent_script <span style="color:#f92672">*</span>zend_accel_script_persist( ... ) 
</code></pre></div><p>到 ext/opcache/zend_persist.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> zend_persist_op_array_ex( ... ) 
</code></pre></div><p>到ext/opcache/jit/zend_jit.c 的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ZEND_API <span style="color:#66d9ef">int</span> zend_jit_op_array( zend_op_array <span style="color:#f92672">*</span>op_array, zend_script <span style="color:#f92672">*</span>script) 
</code></pre></div><p>在这个函数中进行handler的替换。</p>
<h4 id="jit编译的触发">JIT编译的触发</h4>
<p>in ext/opcache/jit/zend_jit.h</p>
<p>这个也就是鸟哥公众号里说的JIT触发策略</p>
<p>有以下几种选择</p>
<p>0 ZEND_JIT_ON_SCRIPT_LOAD  PHP脚本载入的时候就JIT。</p>
<p>1 ZEND_JIT_ON_FIRST_EXEC 当函数第一次被执行时JIT。</p>
<p>2 ZEND_JIT_ON_PROF_REQUEST 在一次运行后，JIT调用次数最多的百分之(opcache.prof_threshold * 100)的函数。</p>
<p>3 ZEND_JIT_ON_HOT_COUNTERS 当函数/方法执行超过N(N和opcache.jit_hot_func相关)次以后JIT。</p>
<p>4 ZEND_JIT_ON_DOC_COMMENT 当函数方法的注释中含有@jit的时候对它进行JIT。</p>
<p>5 ZEND_JIT_ON_HOT_TRACE 当一个Trace执行超过N次（和opcache.jit_hot_loop, jit_hot_return等有关)以后JIT。</p>
<h4 id="zend_jit_on_script_load">ZEND_JIT_ON_SCRIPT_LOAD</h4>
<p>in ext/opcache/jit/zend_jit.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">zend_real_jit_func</span>(op_array, script, NULL); 
</code></pre></div><p>Opcache处理op_array时进行编译，从这个意义上讲，这不是 Just In Time。</p>
<h4 id="zend_jit_on_first_exec">ZEND_JIT_ON_FIRST_EXEC</h4>
<p>in ext/opcache/jit/zend_jit.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">opline<span style="color:#f92672">-&gt;</span>handler <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)zend_runtime_jit; 
</code></pre></div><p>首次执行zend_runtime_jit函数无条件启动JIT编译：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> ZEND_FASTCALL <span style="color:#a6e22e">zend_runtime_jit</span>(<span style="color:#66d9ef">void</span>) {
	...
	<span style="color:#75715e">/* perform real JIT for this function */</span> 
	<span style="color:#75715e">// 执行JIT编译
</span><span style="color:#75715e"></span>	zend_real_jit_func(op_array, NULL, NULL);
	...
}
</code></pre></div><h4 id="zend_jit_on_prof_request">ZEND_JIT_ON_PROF_REQUEST</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">opline<span style="color:#f92672">-&gt;</span>handler <span style="color:#f92672">=</span> zend_jit_profile_helper; 
</code></pre></div><p>zend_jit_profile_helper计算每个op_array的执行次数。</p>
<p>in ext/opcache/jit/zend_jit_vm_helpers.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL <span style="color:#a6e22e">zend_jit_profile_helper</span>(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op_array <span style="color:#f92672">*</span>op_array <span style="color:#f92672">=</span> (zend_op_array<span style="color:#f92672">*</span>)EX(func);
	zend_jit_op_array_extension <span style="color:#f92672">*</span>jit_extension <span style="color:#f92672">=</span> (zend_jit_op_array_extension<span style="color:#f92672">*</span>)ZEND_FUNC_INFO(op_array);

	<span style="color:#75715e">// 获取原本的handler
</span><span style="color:#75715e"></span>	zend_vm_opcode_handler_t handler <span style="color:#f92672">=</span> (zend_vm_opcode_handler_t) jit_extension<span style="color:#f92672">-&gt;</span>orig_handler;

	<span style="color:#75715e">// 这个op_array的执行次数
</span><span style="color:#75715e"></span>	<span style="color:#f92672">++*</span>(uintptr_t<span style="color:#f92672">*</span>)(EX(run_time_cache) <span style="color:#f92672">+</span> zend_jit_profile_counter_rid);

	<span style="color:#75715e">// 所有的op_array的执行次数总和
</span><span style="color:#75715e"></span>	<span style="color:#f92672">++</span>zend_jit_profile_counter;

	<span style="color:#75715e">// 执行本来的处理
</span><span style="color:#75715e"></span>	ZEND_OPCODE_TAIL_CALL(handler);
}
</code></pre></div><p>Opcache资源释放时进行JIT编译。</p>
<p>in ext/opcache/jit/zend_jit.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zend_jit_check_funcs</span>(HashTable <span style="color:#f92672">*</span>function_table, zend_bool is_method) {
	...
	zend_ulong counter <span style="color:#f92672">=</span> (zend_ulong)ZEND_COUNTER_INFO(op_array); 
	<span style="color:#66d9ef">if</span> (((<span style="color:#66d9ef">double</span>)counter <span style="color:#f92672">/</span> (<span style="color:#66d9ef">double</span>)zend_jit_profile_counter) <span style="color:#f92672">&gt;</span> ZEND_JIT_PROF_THRESHOLD) { 
		zend_real_jit_func(op_array, NULL, NULL);
	} 
	...
}
</code></pre></div><p>对执行时间占比超过阈值的op_array使用JIT，而是由最初的请求决定。</p>
<h4 id="zend_jit_on_hot_counters">ZEND_JIT_ON_HOT_COUNTERS</h4>
<p>in ext/opcache/jit/zend_jit.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">zend_jit_setup_hot_counters</span>(op_array);
</code></pre></div><p>以基本块为单位测量执行次数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zend_jit_setup_hot_counters</span>(zend_op_array <span style="color:#f92672">*</span>op_array) {
	... 
	opline<span style="color:#f92672">-&gt;</span>handler <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)zend_jit_func_counter_helper; 

	<span style="color:#75715e">// Control Flow Graph
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> cfg.blocks_count; i<span style="color:#f92672">++</span>) {
		...
		op_array<span style="color:#f92672">-&gt;</span>opcodes[cfg.blocks[i].start].handler <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)zend_jit_loop_counter_helper;
	}
	...
}
</code></pre></div><p>in ext/opcache/jit/zend_jit_vm_helpers.c</p>
<p>每次执行时，都会去减hot counter，如果小于等于0，则进行编译。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> ZEND_FASTCALL <span style="color:#a6e22e">zend_jit_func_counter_helper</span>(<span style="color:#66d9ef">void</span>) {
	...

	<span style="color:#f92672">*</span>(jit_extension<span style="color:#f92672">-&gt;</span>counter) <span style="color:#f92672">-=</span> ((ZEND_JIT_COUNTER_INIT <span style="color:#f92672">+</span> JIT_G(hot_func) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> JIT_G(hot_func));

	<span style="color:#66d9ef">if</span> (UNEXPECTED(<span style="color:#f92672">*</span>(jit_extension<span style="color:#f92672">-&gt;</span>counter) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)) {
		<span style="color:#f92672">*</span>(jit_extension<span style="color:#f92672">-&gt;</span>counter) <span style="color:#f92672">=</span> ZEND_JIT_COUNTER_INIT;

		<span style="color:#75715e">// 恢复处理程序并执行JIT
</span><span style="color:#75715e"></span>		zend_jit_hot_func(execute_data, opline);
		ZEND_OPCODE_RETURN();
	} <span style="color:#66d9ef">else</span> {
		zend_vm_opcode_handler_t handler <span style="color:#f92672">=</span> (zend_vm_opcode_handler_t)jit_extension<span style="color:#f92672">-&gt;</span>orig_handlers[opline <span style="color:#f92672">-</span> EX(func)<span style="color:#f92672">-&gt;</span>op_array.opcodes];
		ZEND_OPCODE_TAIL_CALL(handler);
	}
}
</code></pre></div><p>zend_jit_loop_counter_helper 也是同样的执行逻辑。</p>
<h4 id="zend_jit_on_doc_comment">ZEND_JIT_ON_DOC_COMMENT</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (zend_needs_manual_jit(op_array)) {
  	<span style="color:#66d9ef">return</span> zend_real_jit_func(op_array, script, NULL);
} <span style="color:#66d9ef">else</span> {
	<span style="color:#66d9ef">return</span> SUCCESS;
}
</code></pre></div><p>仅适用于在DocComment中指定@jit的函数，Opcache处理op_array时进行编译，当然这也不是“Just In Time”。</p>
<h2 id="jit编译处理内容">JIT编译处理内容</h2>
<h4 id="zend_real_jit_func">zend_real_jit_func</h4>
<p>in ext/opcache/jit/zend_jit.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zend_real_jit_func</span>(zend_op_array <span style="color:#f92672">*</span>op_array, zend_script <span style="color:#f92672">*</span>script, <span style="color:#66d9ef">const</span> zend_op <span style="color:#f92672">*</span>rt_opline) {
</code></pre></div><p>解析JIT编译（使用Opcache）</p>
<ul>
<li>控制流程图(Control Flow Graph，CFG)的构建</li>
<li>数据流(data flow)分析(ZEND_JIT_LEVEL_OPT_FUNC)</li>
<li>调用图(call graph)构造(ZEND_JIT_LEVEL_OPT_FUNCS)</li>
</ul>
<p>代码的生成</p>
<ul>
<li>根据opcode生成机器码</li>
<li>使用DynASM作为代码生成机制</li>
</ul>
<h4 id="代码生成">代码生成</h4>
<p>in ext/opcache/jit/zend_jit.c</p>
<p>JIT编译的主体</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zend_jit</span>(zend_op_array <span style="color:#f92672">*</span>op_array, zend_ssa <span style="color:#f92672">*</span>ssa, <span style="color:#66d9ef">const</span> zend_op <span style="color:#f92672">*</span>rt_opline) {
	... 
	<span style="color:#75715e">// 编译op_array中包含的每个opcode
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">switch</span> (opline<span style="color:#f92672">-&gt;</span>opcode) {
	...
    	<span style="color:#66d9ef">case</span> ZEND_PRE_INC:
    	<span style="color:#66d9ef">case</span> ZEND_PRE_DEC:
    	<span style="color:#66d9ef">case</span> ZEND_POST_INC:
    	<span style="color:#66d9ef">case</span> ZEND_POST_DEC:
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>zend_jit_inc_dec(<span style="color:#f92672">&amp;</span>dasm_state, opline, op_array, ssa)) { 
				<span style="color:#66d9ef">goto</span> jit_failure;
			}
		<span style="color:#66d9ef">goto</span> done; 
	}
}
</code></pre></div><h4 id="代码生成的实现">代码生成的实现</h4>
<p>以DynASM格式(.dasc)描述</p>
<p>in ext/opcache/jit/zend_jit_x86.dasc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zend_jit_inc_dec</span>(dasm_State <span style="color:#f92672">**</span>Dst, <span style="color:#66d9ef">const</span> zend_op <span style="color:#f92672">*</span>opline, <span style="color:#66d9ef">const</span> zend_op_array <span style="color:#f92672">*</span>op_array, uint32_t op1_info, zend_jit_addr op1_addr, uint32_t op1_def_info, zend_jit_addr op1_def_addr, uint32_t res_use_info, uint32_t res_info, zend_jit_addr res_addr, <span style="color:#66d9ef">int</span> may_overflow, <span style="color:#66d9ef">int</span> may_throw)
{
	<span style="color:#66d9ef">if</span> (op1_info <span style="color:#f92672">&amp;</span> ((MAY_BE_UNDEF<span style="color:#f92672">|</span>MAY_BE_ANY)<span style="color:#f92672">-</span>MAY_BE_LONG)) {
		<span style="color:#f92672">|</span>	IF_NOT_ZVAL_TYPE op1_addr, IS_LONG, <span style="color:#f92672">&gt;</span><span style="color:#ae81ff">2</span>
	}
	<span style="color:#66d9ef">if</span> (opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_POST_INC <span style="color:#f92672">||</span> opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_POST_DEC) {
		<span style="color:#f92672">|</span>	ZVAL_COPY_VALUE res_addr, res_use_info, op1_addr, MAY_BE_LONG, ZREG_R0, ZREG_R1
	}
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>zend_jit_update_regs(Dst, op1_addr, op1_def_addr, MAY_BE_LONG)) {
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
	}
	<span style="color:#66d9ef">if</span> (opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_PRE_INC <span style="color:#f92672">||</span> opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_POST_INC) {
		<span style="color:#f92672">|</span>	LONG_OP_WITH_CONST add, op1_def_addr, Z_L(<span style="color:#ae81ff">1</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#f92672">|</span>	LONG_OP_WITH_CONST sub, op1_def_addr, Z_L(<span style="color:#ae81ff">1</span>)
	}
	...
}
</code></pre></div><p>根据dynasm.lua转换为zend_jit_x86.c</p>
<h4 id="dynasm">DynASM</h4>
<p>之后单独讲这个，简单来说DynASM就是一个方便写汇编的框架。</p>
<p>in ext/opcache/jit/zend_jit_x86.dasc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_PRE_INC <span style="color:#f92672">||</span> opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_POST_INC) { 
	<span style="color:#f92672">|</span> inc aword [FP <span style="color:#f92672">+</span> opline<span style="color:#f92672">-&gt;</span>op1.var]
} <span style="color:#66d9ef">else</span> {
	<span style="color:#f92672">|</span> dec aword [FP <span style="color:#f92672">+</span> opline<span style="color:#f92672">-&gt;</span>op1.var]
}
</code></pre></div><p>生成以下C代码</p>
<p>in ext/opcache/jit/zend_jit_x86.c</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_PRE_INC <span style="color:#f92672">||</span> opline<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">==</span> ZEND_POST_INC) { 
	<span style="color:#75715e">//| inc aword [FP + opline-&gt;op1.var]
</span><span style="color:#75715e"></span>	dasm_put(Dst, <span style="color:#ae81ff">749</span>, opline<span style="color:#f92672">-&gt;</span>op1.var);
} <span style="color:#66d9ef">else</span> {
	<span style="color:#75715e">//| dec aword [FP + opline-&gt;op1.var] dasm_put(Dst, 755, opline-&gt;op1.var);
</span><span style="color:#75715e"></span>}
</code></pre></div><p>简单描述一下就是</p>
<p><img src="&amp;&amp;&amp;SFLOCALFILEPATH&amp;&amp;&amp;B10D10D2-2BBF-41F1-A5A3-B2248AC4879C.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">	<span style="color:#75715e">// 处理所有操作码后之后，将生成的机器语言作为处理程序执行
</span><span style="color:#75715e"></span>	handler <span style="color:#f92672">=</span> dasm_link_and_encode(<span style="color:#f92672">&amp;</span>dasm_state, op_array, <span style="color:#f92672">&amp;</span>ssa<span style="color:#f92672">-&gt;</span>cfg, rt_opline, NULL);
</code></pre></div><h2 id="dynasm-1">DynASM</h2>
<p>最后说一下为什么要用DynASM？</p>
<p>一个简单的JIT最困难的部分是编写目标CPU可以理解的指令。例如在x86-64平台，push rbp这个指令被编码成0x55。这样的编码人几乎看不懂。DynASM采用了一个新颖的方式， 可以在JIT中混合使用汇编代码和C代码，从而可以用一个非常自然和可读的方式实现JIT。它支持很多CPU架构，所以不会因为它对硬件的支持而受到限制。DynASM也格外小巧， 其整个运行时库都包含在500行的头文件中。</p>
<p>所以简单来说DynASM就是一个方便写汇编的框架。</p>
<p>DynASM 是为 luajit 编写的 JIT 汇编预处理器和微型运行时库 (简单来讲, DynASM完成两个工作, 一个是预处理, 把你写的汇编指令 (对, 没有Elixir, DynASM并不能直接把逻辑变成汇编, 需要你手动把你的逻辑用汇编语言重写一遍, 因此性能也取决于你的汇编代码写的好坏) 变成真正的二进制机器码, 另一个是提供一个微型运行时, 来处理那些必须推迟到运行时才能执行的代码).</p>
<p>一个JIT的例子</p>
<h4 id="brainfuck">brainfuck</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">++++++++++<span style="color:#f92672">[</span>&gt;+++++++&gt;++++++++++&gt;+++&gt;+<span style="color:#f92672">&lt;&lt;&lt;</span>&lt;-<span style="color:#f92672">]</span>
&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.
&gt;.+++.------.--------.&gt;+.&gt;.
</code></pre></div><p>这个编译完是输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Hello World!
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TAPE_SIZE 30000
</span><span style="color:#75715e">#define MAX_NESTING 100
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> bf_state
{
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> tape;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">char</span> (<span style="color:#f92672">*</span>get_ch)(<span style="color:#66d9ef">struct</span> bf_state<span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>put_ch)(<span style="color:#66d9ef">struct</span> bf_state<span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>);
} bf_state_t;

<span style="color:#75715e">#define bad_program(s) exit(fprintf(stderr, &#34;bad program near %.16s: %s\n&#34;, program, s))
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bf_interpret</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program, bf_state_t<span style="color:#f92672">*</span> state)
{
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> loops[MAX_NESTING];
  <span style="color:#66d9ef">int</span> nloops <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> n;
  <span style="color:#66d9ef">int</span> nskip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> tape_begin <span style="color:#f92672">=</span> state<span style="color:#f92672">-&gt;</span>tape <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> state<span style="color:#f92672">-&gt;</span>tape;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> tape_end <span style="color:#f92672">=</span> state<span style="color:#f92672">-&gt;</span>tape <span style="color:#f92672">+</span> TAPE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">for</span>(;;) {
    <span style="color:#66d9ef">switch</span>(<span style="color:#f92672">*</span>program<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&lt;&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip) {
        ptr <span style="color:#f92672">-=</span> n;
        <span style="color:#66d9ef">while</span>(ptr <span style="color:#f92672">&lt;=</span> tape_begin)
          ptr <span style="color:#f92672">+=</span> TAPE_SIZE;
      }
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&gt;&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&gt;&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip) {
        ptr <span style="color:#f92672">+=</span> n;
        <span style="color:#66d9ef">while</span>(ptr <span style="color:#f92672">&gt;</span> tape_end)
          ptr <span style="color:#f92672">-=</span> TAPE_SIZE;
      }
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip)
        <span style="color:#f92672">*</span>ptr <span style="color:#f92672">+=</span> n;
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip)
        <span style="color:#f92672">*</span>ptr <span style="color:#f92672">-=</span> n;
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;,&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip)
        <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> state<span style="color:#f92672">-&gt;</span>get_ch(state);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;.&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nskip)
        state<span style="color:#f92672">-&gt;</span>put_ch(state, <span style="color:#f92672">*</span>ptr);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">==</span> MAX_NESTING)
        bad_program(<span style="color:#e6db74">&#34;Nesting too deep&#34;</span>);
      loops[nloops<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> program;
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!*</span>ptr)
        <span style="color:#f92672">++</span>nskip;
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;]&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        bad_program(<span style="color:#e6db74">&#34;] without matching [&#34;</span>);
      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">*</span>ptr)
        program <span style="color:#f92672">=</span> loops[nloops<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
      <span style="color:#66d9ef">else</span>
        <span style="color:#f92672">--</span>nloops;
      <span style="color:#66d9ef">if</span>(nskip)
        <span style="color:#f92672">--</span>nskip;
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
        program <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>, bad_program(<span style="color:#e6db74">&#34;[ without matching ]&#34;</span>);
      <span style="color:#66d9ef">return</span>;
    }
  }
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bf_putchar</span>(bf_state_t<span style="color:#f92672">*</span> s, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> c)
{
  putchar((<span style="color:#66d9ef">int</span>)c);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#a6e22e">bf_getchar</span>(bf_state_t<span style="color:#f92672">*</span> s)
{
  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>)getchar();
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bf_run</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program)
{
  bf_state_t state;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> tape[TAPE_SIZE] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
  state.tape <span style="color:#f92672">=</span> tape;
  state.get_ch <span style="color:#f92672">=</span> bf_getchar;
  state.put_ch <span style="color:#f92672">=</span> bf_putchar;
  bf_interpret(program, <span style="color:#f92672">&amp;</span>state);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv)
{
  <span style="color:#66d9ef">if</span>(argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">long</span> sz;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program;
    FILE<span style="color:#f92672">*</span> f <span style="color:#f92672">=</span> fopen(argv[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;r&#34;</span>);
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>f) {
      fprintf(stderr, <span style="color:#e6db74">&#34;Cannot open %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>]);
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
    fseek(f, <span style="color:#ae81ff">0</span>, SEEK_END);
    sz <span style="color:#f92672">=</span> ftell(f);
    program <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)malloc(sz <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    fseek(f, <span style="color:#ae81ff">0</span>, SEEK_SET);
    program[fread(program, <span style="color:#ae81ff">1</span>, sz, f)] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    fclose(f);
    bf_run(program);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  } <span style="color:#66d9ef">else</span> {
    fprintf(stderr, <span style="color:#e6db74">&#34;Usage: %s INFILE.bf</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }
}
</code></pre></div><p>这个程序用来渲染曼德博集合(Mandelbrot set):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> gcc -o tutorial tutorial.c
./tutorial mandelbrot.bf
</code></pre></div><p><img src="https://s1.ax1x.com/2020/07/22/UbQKOK.png" alt="UbQKOK.png"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./tutorial mandelbrot.bf  67.48s user 0.59s system 44% cpu 2:33.30 total
</code></pre></div><p>花了67.48s</p>
<p>然后用dynasm重新写一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">||</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#66d9ef">if</span> ((defined(_M_X64) <span style="color:#f92672">||</span> defined(__amd64__)) <span style="color:#f92672">!=</span> X64) <span style="color:#f92672">||</span> (defined(_WIN32) <span style="color:#f92672">!=</span> WIN)
<span style="color:#75715e">#error &#34;Wrong DynASM flags used: pass `-D X64` and/or `-D WIN` to dynasm.lua as appropriate&#34;
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;luajit-2.0/dynasm/dasm_proto.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;luajit-2.0/dynasm/dasm_x86.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#if _WIN32
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#else
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#if !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)
</span><span style="color:#75715e">#define MAP_ANONYMOUS MAP_ANON
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> link_and_encode(dasm_State<span style="color:#f92672">**</span> d)
{
  size_t sz;
  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buf;
  dasm_link(d, <span style="color:#f92672">&amp;</span>sz);
<span style="color:#75715e">#ifdef _WIN32
</span><span style="color:#75715e"></span>  buf <span style="color:#f92672">=</span> VirtualAlloc(<span style="color:#ae81ff">0</span>, sz, MEM_RESERVE <span style="color:#f92672">|</span> MEM_COMMIT, PAGE_READWRITE);
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>  buf <span style="color:#f92672">=</span> mmap(<span style="color:#ae81ff">0</span>, sz, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE, MAP_PRIVATE <span style="color:#f92672">|</span> MAP_ANONYMOUS, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>  dasm_encode(d, buf);
<span style="color:#75715e">#ifdef _WIN32
</span><span style="color:#75715e"></span>  {DWORD dwOld; VirtualProtect(buf, sz, PAGE_EXECUTE_READ, <span style="color:#f92672">&amp;</span>dwOld); }
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>  mprotect(buf, sz, PROT_READ <span style="color:#f92672">|</span> PROT_EXEC);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> buf;
}

<span style="color:#75715e">#define TAPE_SIZE 30000
</span><span style="color:#75715e">#define MAX_NESTING 100
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> bf_state
{
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> tape;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">char</span> (<span style="color:#f92672">*</span>get_ch)(<span style="color:#66d9ef">struct</span> bf_state<span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>put_ch)(<span style="color:#66d9ef">struct</span> bf_state<span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>);
} bf_state_t;

<span style="color:#75715e">#define bad_program(s) exit(fprintf(stderr, &#34;bad program near %.16s: %s\n&#34;, program, s))
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">*</span> bf_compile(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program) )(bf_state_t<span style="color:#f92672">*</span>)
{
  <span style="color:#66d9ef">unsigned</span> loops[MAX_NESTING];
  <span style="color:#66d9ef">int</span> nloops <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> n;
  dasm_State<span style="color:#f92672">*</span> d;
  <span style="color:#66d9ef">unsigned</span> npc <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
  <span style="color:#66d9ef">unsigned</span> nextpc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#f92672">|</span>.<span style="color:#66d9ef">if</span> X64
  <span style="color:#f92672">|</span>.arch x64
  <span style="color:#f92672">|</span>.<span style="color:#66d9ef">else</span>
  <span style="color:#f92672">|</span>.arch x86
  <span style="color:#f92672">|</span>.endif
  <span style="color:#f92672">|</span>.section code
  dasm_init(<span style="color:#f92672">&amp;</span>d, DASM_MAXSECTION);
  <span style="color:#f92672">|</span>.globals lbl_
  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> labels[lbl__MAX];
  dasm_setupglobal(<span style="color:#f92672">&amp;</span>d, labels, lbl__MAX);
  <span style="color:#f92672">|</span>.actionlist bf_actions
  dasm_setup(<span style="color:#f92672">&amp;</span>d, bf_actions);
  dasm_growpc(<span style="color:#f92672">&amp;</span>d, npc);
  <span style="color:#f92672">|</span>.<span style="color:#66d9ef">if</span> X64
    <span style="color:#f92672">|</span>.define aPtr, rbx
    <span style="color:#f92672">|</span>.define aState, r12
    <span style="color:#f92672">|</span>.<span style="color:#66d9ef">if</span> WIN
      <span style="color:#f92672">|</span>.define aTapeBegin, rsi
      <span style="color:#f92672">|</span>.define aTapeEnd, rdi
      <span style="color:#f92672">|</span>.define rArg1, rcx
      <span style="color:#f92672">|</span>.define rArg2, rdx
    <span style="color:#f92672">|</span>.<span style="color:#66d9ef">else</span>
      <span style="color:#f92672">|</span>.define aTapeBegin, r13
      <span style="color:#f92672">|</span>.define aTapeEnd, r14
      <span style="color:#f92672">|</span>.define rArg1, rdi
      <span style="color:#f92672">|</span>.define rArg2, rsi
    <span style="color:#f92672">|</span>.endif
    <span style="color:#f92672">|</span>.macro prepcall1, arg1
      <span style="color:#f92672">|</span> mov rArg1, arg1
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro prepcall2, arg1, arg2
      <span style="color:#f92672">|</span> mov rArg1, arg1
      <span style="color:#f92672">|</span> mov rArg2, arg2
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.define postcall, .nop
    <span style="color:#f92672">|</span>.macro prologue
      <span style="color:#f92672">|</span> push aPtr
      <span style="color:#f92672">|</span> push aState
      <span style="color:#f92672">|</span> push aTapeBegin
      <span style="color:#f92672">|</span> push aTapeEnd
      <span style="color:#f92672">|</span> push rax
      <span style="color:#f92672">|</span> mov aState, rArg1
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro epilogue
      <span style="color:#f92672">|</span> pop rax
      <span style="color:#f92672">|</span> pop aTapeEnd
      <span style="color:#f92672">|</span> pop aTapeBegin
      <span style="color:#f92672">|</span> pop aState
      <span style="color:#f92672">|</span> pop aPtr
      <span style="color:#f92672">|</span> ret
    <span style="color:#f92672">|</span>.endmacro
  <span style="color:#f92672">|</span>.<span style="color:#66d9ef">else</span>
    <span style="color:#f92672">|</span>.define aPtr, ebx
    <span style="color:#f92672">|</span>.define aState, ebp
    <span style="color:#f92672">|</span>.define aTapeBegin, esi
    <span style="color:#f92672">|</span>.define aTapeEnd, edi
    <span style="color:#f92672">|</span>.macro prepcall1, arg1
      <span style="color:#f92672">|</span> push arg1
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro prepcall2, arg1, arg2
      <span style="color:#f92672">|</span> push arg2
      <span style="color:#f92672">|</span> push arg1
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro postcall, n
      <span style="color:#f92672">|</span> add esp, <span style="color:#ae81ff">4</span><span style="color:#f92672">*</span>n
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro prologue
      <span style="color:#f92672">|</span> push aPtr
      <span style="color:#f92672">|</span> push aState
      <span style="color:#f92672">|</span> push aTapeBegin
      <span style="color:#f92672">|</span> push aTapeEnd
      <span style="color:#f92672">|</span> mov aState, [esp<span style="color:#f92672">+</span><span style="color:#ae81ff">20</span>]
    <span style="color:#f92672">|</span>.endmacro
    <span style="color:#f92672">|</span>.macro epilogue
      <span style="color:#f92672">|</span> pop aTapeEnd
      <span style="color:#f92672">|</span> pop aTapeBegin
      <span style="color:#f92672">|</span> pop aState
      <span style="color:#f92672">|</span> pop aPtr
      <span style="color:#f92672">|</span> ret <span style="color:#ae81ff">4</span>
    <span style="color:#f92672">|</span>.endmacro
  <span style="color:#f92672">|</span>.endif

  <span style="color:#f92672">|</span>.type state, bf_state_t, aState
  
  dasm_State<span style="color:#f92672">**</span> Dst <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d;
  <span style="color:#f92672">|</span>.code
  <span style="color:#f92672">|-&gt;</span>bf_main:
  <span style="color:#f92672">|</span> prologue
  <span style="color:#f92672">|</span> mov aPtr, state<span style="color:#f92672">-&gt;</span>tape
  <span style="color:#f92672">|</span> lea aTapeBegin, [aPtr<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
  <span style="color:#f92672">|</span> lea aTapeEnd, [aPtr<span style="color:#f92672">+</span>TAPE_SIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
  <span style="color:#66d9ef">for</span>(;;) {
    <span style="color:#66d9ef">switch</span>(<span style="color:#f92672">*</span>program<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&lt;&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#f92672">|</span> sub aPtr, n<span style="color:#f92672">%</span>TAPE_SIZE
      <span style="color:#f92672">|</span> cmp aPtr, aTapeBegin
      <span style="color:#f92672">|</span> ja <span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>
      <span style="color:#f92672">|</span> add aPtr, TAPE_SIZE
      <span style="color:#f92672">|</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&gt;&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&gt;&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#f92672">|</span> add aPtr, n<span style="color:#f92672">%</span>TAPE_SIZE
      <span style="color:#f92672">|</span> cmp aPtr, aTapeEnd
      <span style="color:#f92672">|</span> jbe <span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>
      <span style="color:#f92672">|</span> sub aPtr, TAPE_SIZE
      <span style="color:#f92672">|</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#f92672">|</span> add byte [aPtr], n
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">*</span>program <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>; <span style="color:#f92672">++</span>n, <span style="color:#f92672">++</span>program);
      <span style="color:#f92672">|</span> sub byte [aPtr], n
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;,&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#f92672">|</span> prepcall1 aState
      <span style="color:#f92672">|</span> call aword state<span style="color:#f92672">-&gt;</span>get_ch
      <span style="color:#f92672">|</span> postcall <span style="color:#ae81ff">1</span>
      <span style="color:#f92672">|</span> mov byte [aPtr], al
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;.&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#f92672">|</span> movzx r0, byte [aPtr]
      <span style="color:#f92672">|</span> prepcall2 aState, r0
      <span style="color:#f92672">|</span> call aword state<span style="color:#f92672">-&gt;</span>put_ch
      <span style="color:#f92672">|</span> postcall <span style="color:#ae81ff">2</span>
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">==</span> MAX_NESTING)
        bad_program(<span style="color:#e6db74">&#34;Nesting too deep&#34;</span>);
      <span style="color:#66d9ef">if</span>(program[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">&amp;&amp;</span> program[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;]&#39;</span>) {
        program <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#f92672">|</span> xor eax, eax
        <span style="color:#f92672">|</span> mov byte [aPtr], al
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span>(nextpc <span style="color:#f92672">==</span> npc) {
          npc <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
          dasm_growpc(<span style="color:#f92672">&amp;</span>d, npc);
        }
        <span style="color:#f92672">|</span> cmp byte [aPtr], <span style="color:#ae81ff">0</span>
        <span style="color:#f92672">|</span> jz <span style="color:#f92672">=&gt;</span>nextpc<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        <span style="color:#f92672">|=&gt;</span>nextpc:
        loops[nloops<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nextpc;
        nextpc <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
      }
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;]&#39;</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        bad_program(<span style="color:#e6db74">&#34;] without matching [&#34;</span>);
      <span style="color:#f92672">--</span>nloops;
      <span style="color:#f92672">|</span> cmp byte [aPtr], <span style="color:#ae81ff">0</span>
      <span style="color:#f92672">|</span> jnz <span style="color:#f92672">=&gt;</span>loops[nloops]
      <span style="color:#f92672">|=&gt;</span>loops[nloops]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">if</span>(nloops <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
        program <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>, bad_program(<span style="color:#e6db74">&#34;[ without matching ]&#34;</span>);
      <span style="color:#f92672">|</span> epilogue
      link_and_encode(<span style="color:#f92672">&amp;</span>d);
      dasm_free(<span style="color:#f92672">&amp;</span>d);
      <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)(bf_state_t<span style="color:#f92672">*</span>))labels[lbl_bf_main];
    }
  }
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bf_putchar</span>(bf_state_t<span style="color:#f92672">*</span> s, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> c)
{
  putchar((<span style="color:#66d9ef">int</span>)c);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#a6e22e">bf_getchar</span>(bf_state_t<span style="color:#f92672">*</span> s)
{
  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>)getchar();
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bf_run</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program)
{
  bf_state_t state;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> tape[TAPE_SIZE] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
  state.tape <span style="color:#f92672">=</span> tape;
  state.get_ch <span style="color:#f92672">=</span> bf_getchar;
  state.put_ch <span style="color:#f92672">=</span> bf_putchar;
  bf_compile(program)(<span style="color:#f92672">&amp;</span>state);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv)
{
  <span style="color:#66d9ef">if</span>(argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">long</span> sz;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> program;
    FILE<span style="color:#f92672">*</span> f <span style="color:#f92672">=</span> fopen(argv[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;r&#34;</span>);
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>f) {
      fprintf(stderr, <span style="color:#e6db74">&#34;Cannot open %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>]);
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
    fseek(f, <span style="color:#ae81ff">0</span>, SEEK_END);
    sz <span style="color:#f92672">=</span> ftell(f);
    program <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)malloc(sz <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    fseek(f, <span style="color:#ae81ff">0</span>, SEEK_SET);
    program[fread(program, <span style="color:#ae81ff">1</span>, sz, f)] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    fclose(f);
    bf_run(program);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  } <span style="color:#66d9ef">else</span> {
    fprintf(stderr, <span style="color:#e6db74">&#34;Usage: %s INFILE.bf</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }
}
</code></pre></div><p>为了编译, 首先需要通过 DynASM 预处理程序运行它. 预处理器是用 Lua 编写的, 因此首先编译一个 minimal Lua 解释器 (如果有luajit也可以直接用luajit运行dynasm.lua, 就可以省略这一步):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gcc -o minilua luajit-2.0/src/host/minilua.c
</code></pre></div><p>然后运行 DynASM 预处理器:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./minilua luajit-2.0/dynasm/dynasm.lua -o tutorial.posix64.c -D X64 tutorial.c
</code></pre></div><p>完成预处理后, 调用 C 编译器:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gcc -o tutorial tutorial.posix64.c
</code></pre></div><p>然后, 我们可以运行生成的可执行文件, 该可执行文件将很快运行 Mandelbrot set:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./tutorial mandelbrot.bf
</code></pre></div><p><img src="https://s1.ax1x.com/2020/07/22/UbQQeO.png" alt="UbQQeO.png"></p>
<p>只花了2.11s，jit之前是67.48s，jit后是2.11s，性能提升了接近32倍。</p>
<p>参考的文章，感谢巨人们的肩膀：</p>
<p><a href="https://mp.weixin.qq.com/s/WiFiwCfOqwSNpnmeipkjOg">PHP8新特性JIT使用简介</a><br>
<a href="http://corsix.github.io/dynasm-doc/index.html">The Unofficial DynASM Documentation</a><br>
<a href="http://wuduoyi.com/note/hhvm/">HHVM 是如何提升 PHP 性能的？ - wuduoyi</a><br>
<a href="https://learnku.com/php/t/44968">https://learnku.com/php/t/44968</a></p>


  <footer>
  
  



<script src="//cdn.bootcss.com/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">© <a href="/">zoco</a> 2020</div>
  
  </footer>
  </article>
  
  </body>
</html>

